<canvas id="screen" width="1024" height="1024"/>
<script src="gpu.js"></script>


<script>
var screen = document.getElementById('screen');
var canvas = screen.getContext('2d');



var blocks = []
for (var x = 0; x < 256; x++)
{
	blocks.push([])
	for (var y = 0; y < 256; y++)
	{
		blocks[x].push([])
		for (var z = 0; z < 256; z++)
		{
			var filledBlock = false
			if (Math.random() < 1/64)
			{
				filledBlock = true
			}
			var red = Math.random()
			var green = Math.random() 
			var blue = Math.random()
			var intensity = Math.random()/2+1
			var transparency = Math.random()
			var reflectance = Math.random()
			var bleedthrough = Math.random()
			var brilliance = Math.random() * 1 - 0.5
			blocks[x][y].push(filledBlock, red, green, blue, intensity, transparency, reflectance, bleedthrough, brilliance)
		}
	}	
}
var lx = blocks.length
var ly = blocks[0].length
var lz = blocks[0][0].length
function getBlockFilled(x,y,z)
{
	
	var bx = x
	var by = y
	var bz = z
	if (bx >= 0 && bx < lx && by >= 0 && by < ly && bz >= 0 && bz < lz)
	{
		if (blocks[bx][by][bz].filled == true)
		{
			return 1
		}
	}
	else
	{
		return 2
	}
	return 0
}

var plyX = 0

var plyY = 0

var plyZ = 0


var raycastDist = 50

const gpu = new GPU()
var pixelsX = 1024
var pixelsY = 1024
/*const kernel = gpu.createKernel(function(image) {
    ...
})
  .setGraphical(true)
  .setOutput([100, 100]);

const image = document.createElement('img');
image.src = 'image1.png';
image.onload = () => {
  kernel(image);  
  document.getElementsByTagName('body')[0].appendChild(kernel.canvas);
};*/


const raycast = gpu.createKernel(function(image,lx,ly,lz,camX,camY,camZ,camYaw,camPitch,redEnv,grnEnv,bluEnv,screenwidth,screenheight,raycastDist,blocks) {
	var x = this.thread.x
	var y = this.thread.y
	var len = 9
	var reachedBlock = false
	var rayAngX = Math.atan((x-screenwidth/2)/screenwidth)
	var rayAngY = Math.atan((y-screenheight/2)/screenheight)
	var rayDX = Math.cos(camYaw + rayAngX)*Math.cos(camPitch + rayAngY)
	var rayDY = Math.sin(camYaw + rayAngX)*Math.cos(camPitch + rayAngY)
	var rayDZ = Math.sin(camPitch + rayAngY)
	var rayX = camX + lx/2 + rayDX
	var rayY = camY + ly/2 + rayDY
	var rayZ = camZ + lz/2 + rayDZ
	var tot = Math.sqrt(rayDX * rayDX + rayDY * rayDY + rayDZ * rayDZ)
	rayDX = rayDX / tot
	rayDY = rayDY / tot
	rayDZ = rayDZ / tot
	var origX = rayX
	var origY = rayY
	var origZ = rayZ
	var blocksTraveled = 0;
	var cont = true;
	var currR = redEnv
	var currG = grnEnv
	var currB = bluEnv
	var prevX = rayX
	var prevY = rayY
	var prevZ = rayZ
	var RGBweight = 1
	var onceDoneWarpToX = 0
	var onceDoneWarpToY = 0
	var onceDoneWarpToZ = 0
	var onceDoneWarpToDX = 0
	var onceDoneWarpToDY = 0
	var onceDoneWarpToDZ = 0
	var onceDoneWarpR = 0
	var onceDoneWarpG = 0
	var onceDoneWarpB = 0
	var blockIgnore = false
	var ignoreBlockX = -lx
	var ignoreBlockY = -ly
	var ignoreBlockZ = -lz
	var onceDoneWarpBlocksTraveled = 0
	var prevColorWeight = 0
	var prevColorWeight2 = 0
	var prevRGBWeight = 0
	var warpSet = false
	while (cont && !reachedBlock) //until it hits a block
	{
		var blockX = Math.round(rayX)
		var blockY = Math.round(rayY)
		var blockZ = Math.round(rayZ)
		var result = 0
		if (blockX >= 0 && blockX < lx && blockY >= 0 && blockY < ly && blockZ >= 0 && blockZ < lz)
		{
			if (blocks[blockX][blockY][blockZ*len] == 1)
			{
				result = 1
				if (blockIgnore == true)
				{
					if (blockX == ignoreBlockX && blockY == ignoreBlockY && blockZ == ignoreBlockZ)
					{
						result = 0
					}
				}
			}
		}
		else
		{
			result = 2
		}
		if (result != 2)
		{
			if (result == 0)
			{
				prevX = rayX
				prevY = rayY
				prevZ = rayZ
				var scale = 0.05 / Math.sqrt(rayDX * rayDX + rayDY * rayDY + rayDZ * rayDZ)
				rayX = rayX + rayDX * scale
				rayY = rayY + rayDY * scale
				rayZ = rayZ + rayDZ * scale
				blocksTraveled = blocksTraveled + 1 * scale
				if (blocksTraveled >= raycastDist)
				{
					var DistX = rayX - origX
					var DistY = rayY - origY
					var DistZ = rayZ - origZ
					if (Math.sqrt(DistX * DistX + DistY * DistY + DistZ * DistZ) > raycastDist)
					{
						cont = false
					}
				}
			}
			else
			{
				var blockR = blocks[blockX][blockY][blockZ*len+1]
				var blockG = blocks[blockX][blockY][blockZ*len+2]
				var blockB = blocks[blockX][blockY][blockZ*len+3]
				var intensity = blocks[blockX][blockY][blockZ*len+4]
				var transparency = blocks[blockX][blockY][blockZ*len+5]
				var reflectance = blocks[blockX][blockY][blockZ*len+6]
				var bleedthrough = blocks[blockX][blockY][blockZ*len+7]
				var brilliance = blocks[blockX][blockY][blockZ*len+8]
				if (blocksTraveled >= raycastDist)
				{
					var DistX = rayX - origX
					var DistY = rayY - origY
					var DistZ = rayZ - origZ
					if (Math.sqrt(DistX * DistX + DistY * DistY + DistZ * DistZ) > raycastDist)
					{
						cont = false
					}
				}
				if (reflectance != 0 || transparency != 0)
				{
					if (bleedthrough != 0)
					{
						if (warpSet)
						{
							if (brilliance != -1)
							{
								var currR2 = (currR * prevColorWeight / (1-prevColorWeight2) + onceDoneWarpR) / (1 + prevColorWeight / (1-prevColorWeight2))
								currR = (currR + currR2 * (brilliance)) / (1 + brilliance)
								currR = (onceDoneWarpR * (1-prevColorWeight2) * (1-prevColorWeight) * bleedthrough + currR) / ((1-prevColorWeight2) * (1-prevColorWeight) * bleedthrough + 1)
								var currG2 = (currG * prevColorWeight / (1-prevColorWeight2) + onceDoneWarpG) / (1 + prevColorWeight / (1-prevColorWeight2))
								currG = (currG + currG2 * (brilliance)) / (1 + brilliance)
								currG = (onceDoneWarpG * (1-prevColorWeight2) * (1-prevColorWeight) * bleedthrough + currG) / ((1-prevColorWeight2) * (1-prevColorWeight) * bleedthrough + 1)
								var currB2 = (currB * prevColorWeight / (1-prevColorWeight2) + onceDoneWarpB) / (1 + prevColorWeight / (1-prevColorWeight2))
								currB = (currB + currB2 * (brilliance)) / (1 + brilliance)
								currB = (onceDoneWarpB * (1-prevColorWeight2) * (1-prevColorWeight) * bleedthrough + currB) / ((1-prevColorWeight2) * (1-prevColorWeight) * bleedthrough + 1)
							}
							else
							{
								currR = (currR * prevColorWeight / (1-prevColorWeight2) + onceDoneWarpR) / (1 + prevColorWeight / (1-prevColorWeight2))
								currG = (currG * prevColorWeight / (1-prevColorWeight2) + onceDoneWarpG) / (1 + prevColorWeight / (1-prevColorWeight2))
								currB = (currB * prevColorWeight / (1-prevColorWeight2) + onceDoneWarpB) / (1 + prevColorWeight / (1-prevColorWeight2))
							}
						}
						onceDoneWarpToX = rayX + rayDX * 0.5
						onceDoneWarpToY = rayY + rayDY * 0.5
						onceDoneWarpToZ = rayZ + rayDZ * 0.5
						onceDoneWarpToDX = rayDX
						onceDoneWarpToDY = rayDY
						onceDoneWarpToDZ = rayDZ
						onceDoneWarpR = currR
						onceDoneWarpG = currG
						onceDoneWarpB = currB
						currR = currR - (((1-blockR) * currR * (1-transparency) * intensity) / (RGBweight))
						currG = currG - (((1-blockG) * currG * (1-transparency) * intensity) / (RGBweight))
						currB = currB - (((1-blockB) * currB * (1-transparency) * intensity) / (RGBweight))
						onceDoneWarpBlocksTraveled = blocksTraveled + 0.05
						prevColorWeight = reflectance
						prevColorWeight2 = transparency
						prevRGBWeight = RGBweight
						warpSet = true
					}
				}
				if (reflectance != 0)
				{	
					currR = (currR * RGBweight + blockR * (1-transparency) * intensity) / ((1-transparency) * intensity + RGBweight)
					currG = (currG * RGBweight + blockG * (1-transparency) * intensity) / ((1-transparency) * intensity + RGBweight)
					currB = (currB * RGBweight + blockB * (1-transparency) * intensity) / ((1-transparency) * intensity + RGBweight)
					RGBweight = RGBweight + 1/reflectance
					var xpos = rayX % 1
					var x2 = Math.abs(xpos - 0.5)
					var ypos = rayY % 1
					var y2 = Math.abs(ypos - 0.5)
					var zpos = rayZ % 1
					var z2 = Math.abs(zpos - 0.5)
					if (x2 < y2 && x2 < z2)
					{
						rayDX = rayDX * -1
					}
					else
					{
						if (y2 < x2 && y2 < z2)
						{
							rayDY = rayDY * -1
						}
						else
						{
							rayDZ = rayDZ * -1
						}
					}
				}
				prevX = rayX
				prevY = rayY
				prevZ = rayZ
				var scale = Math.sqrt(3)
				rayX = rayX + rayDX * scale
				rayY = rayY + rayDY * scale
				rayZ = rayZ + rayDZ * scale
				blocksTraveled = blocksTraveled + 1 * scale
				if (transparency == 0)
				{
					//RGBweight = RGBweight + finalDist
					currR = (currR * RGBweight + blockR * intensity) / (intensity + RGBweight)
					currG = (currG * RGBweight + blockG * intensity) / (intensity + RGBweight)
					currB = (currB * RGBweight + blockB * intensity) / (intensity + RGBweight)
				}
				else
				{
					var Xdist = rayX - prevX
					var Ydist = rayY - prevY
					var Zdist = rayZ - prevZ
					var finalDist = Math.sqrt(Xdist * Xdist + Ydist * Ydist + Zdist * Zdist) * (1 - transparency)
					RGBweight = RGBweight + finalDist
					var rOut = (((1-blockR) * currR * (1-transparency) * intensity) / (RGBweight))
					currR = currR - rOut
					currR = (currR + (1-rOut) * -brilliance) / (1 - brilliance)
					var gOut = (((1-blockG) * currG * (1-transparency) * intensity) / (RGBweight))
					currG = currG - gOut
					currG = (currG + (1-gOut) * -brilliance) / (1 - brilliance)
					var bOut =  (((1-blockB) * currB * (1-transparency) * intensity) / (RGBweight))
					currB = currB - bOut
					currB = (currB + (1-bOut) * -brilliance) / (1 - brilliance)
					
				}
				if (transparency == 0 && reflectance == 0)
				{
					reachedBlock = true
				}
			}
		}
		else
		{
			cont = false
		}
		if (cont == false || reachedBlock == true)
		{
			if (warpSet == true)
			{
				warpSet = false
				cont = true
				reachedBlock = false
				rayX = onceDoneWarpToX
				rayY = onceDoneWarpToY
				rayZ = onceDoneWarpToZ
				rayDX = onceDoneWarpToDX
				rayDY = onceDoneWarpToDY
				rayDZ = onceDoneWarpToDZ
				blockIgnore = true
				ignoreBlockX = Math.floor(rayX)
				ignoreBlockY = Math.floor(rayY)
				ignoreBlockZ = Math.floor(rayZ)
				blocksTraveled = onceDoneWarpBlocksTraveled
				RGBweight = prevRGBWeight
				currR = (currR * prevColorWeight / (1-prevColorWeight2) + onceDoneWarpR) / (1 + prevColorWeight / (1-prevColorWeight2))
				currG = (currG * prevColorWeight / (1-prevColorWeight2) + onceDoneWarpG) / (1 + prevColorWeight / (1-prevColorWeight2))
				currB = (currB * prevColorWeight / (1-prevColorWeight2) + onceDoneWarpB) / (1 + prevColorWeight / (1-prevColorWeight2))
			}	
		}
	}
	//currR = currR - 1
	//currG = currG - 1
	//currB = currB - 1
	const pix = image[this.thread.y][this.thread.x];
	this.color(currR,currG,currB, pix[3]);
}).setGraphical(true).setOutput([pixelsX,pixelsY]);


var yaw = 0
var pitch = 0
function Main() {
	canvas.fillStyle = "#ffffff"
	canvas.fillRect(0,0,screen.width,screen.height)
	canvas.fillStyle = "#000000"
	yaw = yaw + 0.005
	const image = new Image(pixelsX, pixelsY);
	raycast(image,lx,ly,lz,plyX,plyY,plyZ,yaw,pitch,1,1,1,pixelsX,pixelsY,raycastDist,blocks)
	canvas.drawImage(raycast.canvas,0,0);
}
setInterval(Main,1)




</script>
